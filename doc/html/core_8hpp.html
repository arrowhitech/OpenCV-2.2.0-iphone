<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>opencv: /Users/jjthrash/Downloads/OpenCV-2.2.0/modules/core/include/opencv2/core/core.hpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.2 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#define-members">Defines</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>/Users/jjthrash/Downloads/OpenCV-2.2.0/modules/core/include/opencv2/core/core.hpp File Reference</h1>  </div>
</div>
<div class="contents">

<p>The Core Functionality.  
<a href="#_details">More...</a></p>

<p><a href="core_8hpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_allocator.html">cv::Allocator&lt; _Tp &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_auto_buffer.html">cv::AutoBuffer&lt; _Tp, fixed_size &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_complex.html">cv::Complex&lt; _Tp &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_data_depth.html">cv::DataDepth&lt; _Tp &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_data_depth_3_01___tp_01_5_01_4.html">cv::DataDepth&lt; _Tp * &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_data_depth_3_01bool_01_4.html">cv::DataDepth&lt; bool &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_data_depth_3_01char_01_4.html">cv::DataDepth&lt; char &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_data_depth_3_01double_01_4.html">cv::DataDepth&lt; double &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_data_depth_3_01float_01_4.html">cv::DataDepth&lt; float &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_data_depth_3_01int_01_4.html">cv::DataDepth&lt; int &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_data_depth_3_01schar_01_4.html">cv::DataDepth&lt; schar &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_data_depth_3_01short_01_4.html">cv::DataDepth&lt; short &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_data_depth_3_01uchar_01_4.html">cv::DataDepth&lt; uchar &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_data_depth_3_01unsigned_01_4.html">cv::DataDepth&lt; unsigned &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_data_depth_3_01ushort_01_4.html">cv::DataDepth&lt; ushort &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_data_type.html">cv::DataType&lt; _Tp &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_data_type_3_01bool_01_4.html">cv::DataType&lt; bool &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_data_type_3_01char_01_4.html">cv::DataType&lt; char &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_data_type_3_01_complex_3_01___tp_01_4_01_4.html">cv::DataType&lt; Complex&lt; _Tp &gt; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_data_type_3_01double_01_4.html">cv::DataType&lt; double &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_data_type_3_01float_01_4.html">cv::DataType&lt; float &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_data_type_3_01int_01_4.html">cv::DataType&lt; int &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_data_type_3_01_point3___3_01___tp_01_4_01_4.html">cv::DataType&lt; Point3_&lt; _Tp &gt; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_data_type_3_01_point___3_01___tp_01_4_01_4.html">cv::DataType&lt; Point_&lt; _Tp &gt; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_data_type_3_01_range_01_4.html">cv::DataType&lt; Range &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_data_type_3_01_rect___3_01___tp_01_4_01_4.html">cv::DataType&lt; Rect_&lt; _Tp &gt; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_data_type_3_01_scalar___3_01___tp_01_4_01_4.html">cv::DataType&lt; Scalar_&lt; _Tp &gt; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_data_type_3_01schar_01_4.html">cv::DataType&lt; schar &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_data_type_3_01short_01_4.html">cv::DataType&lt; short &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_data_type_3_01_size___3_01___tp_01_4_01_4.html">cv::DataType&lt; Size_&lt; _Tp &gt; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_data_type_3_01std_1_1complex_3_01___tp_01_4_01_4.html">cv::DataType&lt; std::complex&lt; _Tp &gt; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_data_type_3_01uchar_01_4.html">cv::DataType&lt; uchar &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_data_type_3_01ushort_01_4.html">cv::DataType&lt; ushort &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_data_type_3_01_vec_3_01___tp_00_01cn_01_4_01_4.html">cv::DataType&lt; Vec&lt; _Tp, cn &gt; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_exception.html">cv::Exception</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_file_node.html">cv::FileNode</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_file_node_iterator.html">cv::FileNodeIterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_file_storage.html">cv::FileStorage</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcv_1_1_sparse_mat_1_1_hdr.html">cv::SparseMat::Hdr</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">the sparse matrix header  <a href="structcv_1_1_sparse_mat_1_1_hdr.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_k_d_tree.html">cv::KDTree</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_line_iterator.html">cv::LineIterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html">cv::Mat</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat__.html">cv::Mat_&lt; _Tp &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat_allocator.html">cv::MatAllocator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat_comma_initializer__.html">cv::MatCommaInitializer_&lt; _Tp &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat_const_iterator.html">cv::MatConstIterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat_const_iterator__.html">cv::MatConstIterator_&lt; _Tp &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat_iterator__.html">cv::MatIterator_&lt; _Tp &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_matx.html">cv::Matx&lt; _Tp, m, n &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcv_1_1_matx___add_op.html">cv::Matx_AddOp</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcv_1_1_matx___mat_mul_op.html">cv::Matx_MatMulOp</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcv_1_1_matx___mul_op.html">cv::Matx_MulOp</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcv_1_1_matx___scale_op.html">cv::Matx_ScaleOp</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcv_1_1_matx___sub_op.html">cv::Matx_SubOp</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcv_1_1_matx___t_op.html">cv::Matx_TOp</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_matx_comma_initializer.html">cv::MatxCommaInitializer&lt; _Tp, m, n &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcv_1_1_mat_1_1_m_size.html">cv::Mat::MSize</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcv_1_1_mat_1_1_m_step.html">cv::Mat::MStep</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_n_ary_mat_iterator.html">cv::NAryMatIterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcv_1_1_k_d_tree_1_1_node.html">cv::KDTree::Node</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcv_1_1_sparse_mat_1_1_node.html">cv::SparseMat::Node</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">sparse matrix node - element of a hash table  <a href="structcv_1_1_sparse_mat_1_1_node.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_p_c_a.html">cv::PCA</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_point3__.html">cv::Point3_&lt; _Tp &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_point__.html">cv::Point_&lt; _Tp &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_ptr.html">cv::Ptr&lt; _Tp &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_range.html">cv::Range</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_allocator_1_1rebind.html">cv::Allocator&lt; _Tp &gt;::rebind&lt; U &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_rect__.html">cv::Rect_&lt; _Tp &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_r_n_g.html">cv::RNG</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_rotated_rect.html">cv::RotatedRect</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_scalar__.html">cv::Scalar_&lt; _Tp &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_seq.html">cv::Seq&lt; _Tp &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_seq_iterator.html">cv::SeqIterator&lt; _Tp &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_size__.html">cv::Size_&lt; _Tp &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html">cv::SparseMat</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat__.html">cv::SparseMat_&lt; _Tp &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat_const_iterator.html">cv::SparseMatConstIterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat_const_iterator__.html">cv::SparseMatConstIterator_&lt; _Tp &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat_iterator.html">cv::SparseMatIterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat_iterator__.html">cv::SparseMatIterator_&lt; _Tp &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_s_v_d.html">cv::SVD</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_term_criteria.html">cv::TermCriteria</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_vec.html">cv::Vec&lt; _Tp, cn &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_vec_comma_initializer.html">cv::VecCommaInitializer&lt; _Tp, m &gt;</a></td></tr>
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html">cv</a></td></tr>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="core_8hpp.html#af62bcd90f70e275191ab95136d85906b">CV_Assert</a>(expr)&#160;&#160;&#160;if((expr)) ; else cv::error( <a class="el" href="classcv_1_1_exception.html">cv::Exception</a>(CV_StsAssert, #expr, &quot;&quot;, __FILE__, __LINE__) )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="core_8hpp.html#afbcb487cba05bd288dbe18c433de4f6f">CV_DbgAssert</a>(expr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="core_8hpp.html#a5b48c333c777666e076bd7052799f891">CV_Error</a>(code, msg)&#160;&#160;&#160;cv::error( <a class="el" href="classcv_1_1_exception.html">cv::Exception</a>(code, msg, &quot;&quot;, __FILE__, __LINE__) )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="core_8hpp.html#a1c0cd6e5bd9a5f915c6cab9c0632f969">CV_Error_</a>(code, args)&#160;&#160;&#160;cv::error( <a class="el" href="classcv_1_1_exception.html">cv::Exception</a>(code, cv::format args, &quot;&quot;, __FILE__, __LINE__) )</td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a3a5d93a0cbc1d360dbd3abf218bbb4ae">cv::Complexd</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Complex&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#aab0325d447419758daf5de162ffb051f">cv::Complexf</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a178118cdbb19b708b986d0db39cd284c">cv::ConvertData</a> )(const void *from, void *to, int cn)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ab317e9c58ba1be9f7613e021606b1ba8">cv::ConvertScaleData</a> )(const void *from, void *to, int cn, double alpha, double beta)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef int(CV_CDECL *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#afd26af5e3bb46562f232b763ca1e31fe">cv::ErrorCallback</a> )(int status, const char *func_name, const char *err_msg, const char *file_name, int line, void *userdata)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Mat_&lt; <a class="el" href="core_2include_2opencv2_2core_2types__c_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a1d355af1bc5c7241588bdb3600951515">cv::Mat1b</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Mat_&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a8dc8a9e248a8885bb3c61d35f07b61ed">cv::Mat1d</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Mat_&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a9747ac59f97cbb93ddd719c4fb3e2d5d">cv::Mat1f</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Mat_&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a87332e283de569e7bb029d4f4b401dcc">cv::Mat1i</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Mat_&lt; short &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a0c456856506ff905ce035acec092ef9f">cv::Mat1s</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Mat_&lt; <a class="el" href="core_2include_2opencv2_2core_2types__c_8h.html#ab95f123a6c9bcfee6a343170ef8c5f69">ushort</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a4895c2ba170884f13b4a1b1c80fea8ff">cv::Mat1w</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Mat_&lt; Vec2b &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#af7e98a9c920ba16ba08b99bb53c52224">cv::Mat2b</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Mat_&lt; Vec2d &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a04278ad1d5a287e15c07239d6119fe0a">cv::Mat2d</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Mat_&lt; Vec2f &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a5d6e8769d5f6a8b21eb59137e643f095">cv::Mat2f</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Mat_&lt; Vec2i &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a1ee6db17208ebd8bef5749d81267bf17">cv::Mat2i</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Mat_&lt; Vec2s &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#af945be4c317df201188e50e578e1fa75">cv::Mat2s</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Mat_&lt; Vec2w &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#aeb96ec2e3fd29bc27da746681e692b60">cv::Mat2w</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Mat_&lt; Vec3b &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a7198dbdcacbcde70f7c7d1209d57146a">cv::Mat3b</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Mat_&lt; Vec3d &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#af14b1aa52fc952072c0b653f916ffac8">cv::Mat3d</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Mat_&lt; Vec3f &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a8ee031423ba0ecb65fef2bc40abd970e">cv::Mat3f</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Mat_&lt; Vec3i &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a89d566f26821c717c666d31bcfc6bf35">cv::Mat3i</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Mat_&lt; Vec3s &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a4c3cec2bb940613dec561e59b0948801">cv::Mat3s</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Mat_&lt; Vec3w &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a5574e954e5acfdb4e1e03e1dbd8bab6a">cv::Mat3w</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Mat_&lt; Vec4b &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a38bd307d9a0cac4c335e648ef8b63a3e">cv::Mat4b</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Mat_&lt; Vec4d &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ab7781ee46e4a6148e037be23217201dc">cv::Mat4d</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Mat_&lt; Vec4f &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a781cc98063ecb8e02e3576140714842f">cv::Mat4f</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Mat_&lt; Vec4i &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a8895fd82b424209f63bf9713fd5259a2">cv::Mat4i</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Mat_&lt; Vec4s &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a7de7f3b26b41d7326e85ab2e5d9eb1c4">cv::Mat4s</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Mat_&lt; Vec4w &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a66c490bf66285c5cb0b5a21696d0cd03">cv::Mat4w</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a6b0d4d0beaa2627059f06321b1572f9f">cv::MatND</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Matx&lt; double, 1, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a2e67dac932ed81c0c90e3d658c0f7033">cv::Matx12d</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Matx&lt; float, 1, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a3a2cc9d733bf60e0200fa46196805153">cv::Matx12f</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Matx&lt; double, 1, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a765ff587743f231c87ffa708f6f76b96">cv::Matx13d</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Matx&lt; float, 1, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a0af99d4dbb40a817429f3039700f8a33">cv::Matx13f</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Matx&lt; double, 1, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a3a3e911d56f0e29d34cca18548bfdbbf">cv::Matx14d</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Matx&lt; float, 1, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#af1a460d05e81b372d31b50169ec289d6">cv::Matx14f</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Matx&lt; double, 1, 6 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a3afc2be04e64e50bd58296878ec38a1b">cv::Matx16d</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Matx&lt; float, 1, 6 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a7cf48157727556c640df2854f11ff91a">cv::Matx16f</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Matx&lt; double, 2, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a088ad84a55a0fa104ccb9f828dc38299">cv::Matx21d</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Matx&lt; float, 2, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a37e9c8ab7c9ccf91d4b512c656664886">cv::Matx21f</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Matx&lt; double, 2, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a10d0d07f3ac00f086e0fc532790ccc8c">cv::Matx22d</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Matx&lt; float, 2, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a8f480b4b705baac0f2bc1a7db43809ce">cv::Matx22f</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Matx&lt; double, 2, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a392a6836e5dbc164888f4e39c7d9d9af">cv::Matx23d</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Matx&lt; float, 2, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#aa52e0258d92b0ff1be1644b061e65f66">cv::Matx23f</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Matx&lt; double, 3, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a778f9bbae8b0fe95271de44ac24083b0">cv::Matx31d</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Matx&lt; float, 3, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a1625ab2c70d7f06d259f245cb5f5f4f8">cv::Matx31f</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Matx&lt; double, 3, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a0d13e4d37f158c9e3f2d3a047849e626">cv::Matx32d</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Matx&lt; float, 3, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a6d016ebac929fa7bb2fa4f3ebdb9e953">cv::Matx32f</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Matx&lt; double, 3, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#aff0100a48f049fb15584a4a657eae838">cv::Matx33d</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Matx&lt; float, 3, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a118a383f60581636c7c8ab180cbb155e">cv::Matx33f</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Matx&lt; double, 3, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a2ac31d988d1a8b5fb959d395dba89890">cv::Matx34d</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Matx&lt; float, 3, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#aec7e9859876e96fe9ee16e01b6f359b1">cv::Matx34f</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Matx&lt; double, 4, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#afb03ffa6748e6d6e53e997e4975c6404">cv::Matx41d</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Matx&lt; float, 4, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a9a196e7bdf588d7c685edbb330f74423">cv::Matx41f</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Matx&lt; double, 4, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a7db1c513c2dfacc11b83ed8a8c500304">cv::Matx43d</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Matx&lt; float, 4, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ac6f34340fe75178e5a11a77150a3303d">cv::Matx43f</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Matx&lt; double, 4, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a366070cdc95233a6b6db521dfd99e713">cv::Matx44d</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Matx&lt; float, 4, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#aaccfdd6e633076501c97b6ba4e792f53">cv::Matx44f</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Matx&lt; double, 6, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a95ed8b37f47393d8d9a50d9571c7be48">cv::Matx61d</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Matx&lt; float, 6, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a449bf946575de9dc943e74566a0c5e7e">cv::Matx61f</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Matx&lt; double, 6, 6 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#afeab5cbf4078b280e11c59338435cd5c">cv::Matx66d</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Matx&lt; float, 6, 6 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#af1482aa6880dc74dad16683fd0ecc11e">cv::Matx66f</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Ptr&lt; <a class="el" href="struct_cv_mem_storage.html">CvMemStorage</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#addc0d7042a479360085ed66ce96e7302">cv::MemStorage</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Point2i&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a1e83eafb2d26b3c93f09e8338bcab192">cv::Point</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Point_&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a32986d8c6fd05949688352abd112509f">cv::Point2d</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Point_&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a7d080aa40de011e4410bca63385ffe2a">cv::Point2f</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Point_&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a0f70b52f0c0b119f7ed2448ffebdc144">cv::Point2i</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Point3_&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a17f8af95b76535bd387f4909850c8810">cv::Point3d</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Point3_&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a3d79ceeb4419bccd0308dfdf1cd31435">cv::Point3f</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Point3_&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ac4ae8f2fb37ecb4b5d9268f17e46a18e">cv::Point3i</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Rect_&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a954f5c2ab7c3f0f5d4eed444cdabf038">cv::Rect</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Scalar_&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a599fe92e910c027be274233eccad7beb">cv::Scalar</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Size2i&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a346f563897249351a34549137c8532a0">cv::Size</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Size_&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ab34496d2466b5f69930ab74c70f117d4">cv::Size2f</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Size_&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a5ef7f5978948e0cb3c3a3d4172594aec">cv::Size2i</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a1f6634802eeadfd7245bc75cf3e216c2">cv::String</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Vec&lt; <a class="el" href="core_2include_2opencv2_2core_2types__c_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a595458e63aa1443ddd5c51fa71d70e2a">cv::Vec2b</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Vec&lt; double, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#af20d857c2077c986d3b303e3d58bbc54">cv::Vec2d</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Vec&lt; float, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a392bb4f8a6b9e0dde07f31dc28e73319">cv::Vec2f</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Vec&lt; int, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a121402b88177c336b18945dd71d96ae0">cv::Vec2i</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Vec&lt; short, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a8c8616b035cf33c4b2b02fd7b89d6335">cv::Vec2s</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Vec&lt; <a class="el" href="core_2include_2opencv2_2core_2types__c_8h.html#ab95f123a6c9bcfee6a343170ef8c5f69">ushort</a>, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a622811ee01673a858f41b4fbfd4b1043">cv::Vec2w</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Vec&lt; <a class="el" href="core_2include_2opencv2_2core_2types__c_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a7e6060c0b8d48459964df6e1eb524c03">cv::Vec3b</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Vec&lt; double, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a370d94209693b5b13437ab4991cabf73">cv::Vec3d</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Vec&lt; float, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ab9e0ab642a3e01742916763173b72232">cv::Vec3f</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Vec&lt; int, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a55864bca2bbede9731df5baa0d1be763">cv::Vec3i</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Vec&lt; short, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a2a2f4663171710b47944de9a74383dd0">cv::Vec3s</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Vec&lt; <a class="el" href="core_2include_2opencv2_2core_2types__c_8h.html#ab95f123a6c9bcfee6a343170ef8c5f69">ushort</a>, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ac2ca2e7d93b15bc56b379fd5c42c0932">cv::Vec3w</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Vec&lt; <a class="el" href="core_2include_2opencv2_2core_2types__c_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ac8e7c61fdf0d8d9f6e8be7c25dc36584">cv::Vec4b</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Vec&lt; double, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a41502c424d368098331a348dc26141bf">cv::Vec4d</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Vec&lt; float, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a4f29b2178d21a471ee688b14d66d6567">cv::Vec4f</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Vec&lt; int, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a94ce799099ae6cdd66685e3fd0cad7d7">cv::Vec4i</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Vec&lt; short, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a40acb05e3e183aabebc77a235389b582">cv::Vec4s</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Vec&lt; <a class="el" href="core_2include_2opencv2_2core_2types__c_8h.html#ab95f123a6c9bcfee6a343170ef8c5f69">ushort</a>, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a50f51484537d86bd43ff14c681ee3abd">cv::Vec4w</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Vec&lt; double, 6 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a07a801beb07134f7090e3d789ca7c324">cv::Vec6d</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Vec&lt; float, 6 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a74b819dd94c6a8c6f3d8cc39aeaa4992">cv::Vec6f</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::basic_string<br class="typebreak"/>
&lt; wchar_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a563111b3c46f1242cae9541b70c3436c">cv::WString</a></td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br/>
&#160;&#160;<a class="el" href="namespacecv.html#aa40afca20bac89db1ccab192069bfcaba247a3455cd64973152e17e26999dc024">cv::DECOMP_LU</a> = 0, 
<a class="el" href="namespacecv.html#aa40afca20bac89db1ccab192069bfcaba523b676c90c7a1d2841b1267ba9ba614">cv::DECOMP_SVD</a> = 1, 
<a class="el" href="namespacecv.html#aa40afca20bac89db1ccab192069bfcaba3fc1b148b39f0ca4ac5fc6e0f1b7198b">cv::DECOMP_EIG</a> = 2, 
<a class="el" href="namespacecv.html#aa40afca20bac89db1ccab192069bfcaba33cf860f98004310374a81d2c01715da">cv::DECOMP_CHOLESKY</a> = 3, 
<br/>
&#160;&#160;<a class="el" href="namespacecv.html#aa40afca20bac89db1ccab192069bfcabab086be5a080138d7db9b11dab378d845">cv::DECOMP_QR</a> = 4, 
<a class="el" href="namespacecv.html#aa40afca20bac89db1ccab192069bfcaba13eaae0241295166140291223db12166">cv::DECOMP_NORMAL</a> = 16
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br/>
&#160;&#160;<a class="el" href="namespacecv.html#a9e8ffd0cccc9273e9334d80db2a14d15ad33872d928c74f8a49d1ba06d72aefc3">cv::NORM_INF</a> = 1, 
<a class="el" href="namespacecv.html#a9e8ffd0cccc9273e9334d80db2a14d15ab55c78ff204a979026c026ea19de65c9">cv::NORM_L1</a> = 2, 
<a class="el" href="namespacecv.html#a9e8ffd0cccc9273e9334d80db2a14d15a7bacbe84d400336a8f26297d8e80e3a2">cv::NORM_L2</a> = 4, 
<a class="el" href="namespacecv.html#a9e8ffd0cccc9273e9334d80db2a14d15aaabf1ea549554e2cbdfde2acfcfc5374">cv::NORM_TYPE_MASK</a> = 7, 
<br/>
&#160;&#160;<a class="el" href="namespacecv.html#a9e8ffd0cccc9273e9334d80db2a14d15a0a85f9203dcdf3fbc1cca589b6f5df39">cv::NORM_RELATIVE</a> = 8, 
<a class="el" href="namespacecv.html#a9e8ffd0cccc9273e9334d80db2a14d15a9f0c1c342a18114d47b516a88e29822e">cv::NORM_MINMAX</a> = 32
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br/>
&#160;&#160;<a class="el" href="namespacecv.html#a399140175919325d93e19dc058339ec8a878fbe5d23e277c3d87128a8844e639d">cv::CMP_EQ</a> = 0, 
<a class="el" href="namespacecv.html#a399140175919325d93e19dc058339ec8ada5167eceeaca5a3dc9d7f6a96255827">cv::CMP_GT</a> = 1, 
<a class="el" href="namespacecv.html#a399140175919325d93e19dc058339ec8a0dd1b1a6fa443343f44aef8c52942625">cv::CMP_GE</a> = 2, 
<a class="el" href="namespacecv.html#a399140175919325d93e19dc058339ec8a5a747de43c04d59b6e51a2959a8af105">cv::CMP_LT</a> = 3, 
<br/>
&#160;&#160;<a class="el" href="namespacecv.html#a399140175919325d93e19dc058339ec8a45cc5be6c7f35292542aa7c00ce4cf1c">cv::CMP_LE</a> = 4, 
<a class="el" href="namespacecv.html#a399140175919325d93e19dc058339ec8a7997997a104b827c918884b6c5ee0e59">cv::CMP_NE</a> = 5
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="namespacecv.html#a4bb30260c91cf16302d400008c824416a04b6ef29f9ae9332d139828ffc7c1f39">cv::GEMM_1_T</a> = 1, 
<a class="el" href="namespacecv.html#a4bb30260c91cf16302d400008c824416a188bdf58e57b4b8f0685451ba15cdd2d">cv::GEMM_2_T</a> = 2, 
<a class="el" href="namespacecv.html#a4bb30260c91cf16302d400008c824416a6ba75d49e23663b42c4cc5dcd1cc5752">cv::GEMM_3_T</a> = 4
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br/>
&#160;&#160;<a class="el" href="namespacecv.html#a393fbd89880a50a6b584eaa2f646088aa4e01d7e91cae1dbb68a26767d7b636be">cv::DFT_INVERSE</a> = 1, 
<a class="el" href="namespacecv.html#a393fbd89880a50a6b584eaa2f646088aa74746fb171aa4bfc08ace28d73f52375">cv::DFT_SCALE</a> = 2, 
<a class="el" href="namespacecv.html#a393fbd89880a50a6b584eaa2f646088aa1744dc1cf1249944bc841e78c1565b7f">cv::DFT_ROWS</a> = 4, 
<a class="el" href="namespacecv.html#a393fbd89880a50a6b584eaa2f646088aa07b45079b38d60e7837dfb666a55299b">cv::DFT_COMPLEX_OUTPUT</a> = 16, 
<br/>
&#160;&#160;<a class="el" href="namespacecv.html#a393fbd89880a50a6b584eaa2f646088aa28347c7846e5eaed83e019cd003e8e03">cv::DFT_REAL_OUTPUT</a> = 32, 
<a class="el" href="namespacecv.html#a393fbd89880a50a6b584eaa2f646088aa7d18108cbce9d52e6496633c713587da">cv::DCT_INVERSE</a> =  DFT_INVERSE, 
<a class="el" href="namespacecv.html#a393fbd89880a50a6b584eaa2f646088aa49bc8de8aedbe7fabb8960445133e494">cv::DCT_ROWS</a> = DFT_ROWS
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="namespacecv.html#ae47e362ab6bd9ea60b7c0c75495e8f7baae866dad5f28d95c6849ab089d29a7c2">cv::MAGIC_MASK</a> = 0xFFFF0000, 
<a class="el" href="namespacecv.html#ae47e362ab6bd9ea60b7c0c75495e8f7bacdf6078de739c1e49ec21f27f01836ee">cv::TYPE_MASK</a> = 0x00000FFF, 
<a class="el" href="namespacecv.html#ae47e362ab6bd9ea60b7c0c75495e8f7baeff805d7e95884dcd6f0bc7184a67739">cv::DEPTH_MASK</a> = 7
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="namespacecv.html#a234057c65114861f52a325c0aa192addadfa80a38dfc0aef0de888c3164f33faf">cv::KMEANS_RANDOM_CENTERS</a> = 0, 
<a class="el" href="namespacecv.html#a234057c65114861f52a325c0aa192adda78ddd00a99cd51db10ed63c024eb1e62">cv::KMEANS_PP_CENTERS</a> = 2, 
<a class="el" href="namespacecv.html#a234057c65114861f52a325c0aa192adda40625baa3d28c780813f9634b960b366">cv::KMEANS_USE_INITIAL_LABELS</a> = 1
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br/>
&#160;&#160;<a class="el" href="namespacecv.html#a8e6ef4dc51f3daf2c6820f5ecf486adaafff8b973668df2e4028dddc5274310c9">cv::FONT_HERSHEY_SIMPLEX</a> =  0, 
<a class="el" href="namespacecv.html#a8e6ef4dc51f3daf2c6820f5ecf486adaa08cf3b0a37729fbb62a3007d499cbd8b">cv::FONT_HERSHEY_PLAIN</a> =  1, 
<a class="el" href="namespacecv.html#a8e6ef4dc51f3daf2c6820f5ecf486adaab307bdc73fdd06074acad940115bda7a">cv::FONT_HERSHEY_DUPLEX</a> =  2, 
<a class="el" href="namespacecv.html#a8e6ef4dc51f3daf2c6820f5ecf486adaaf7b1b25521fc9b5731a97cfd13460c2a">cv::FONT_HERSHEY_COMPLEX</a> =  3, 
<br/>
&#160;&#160;<a class="el" href="namespacecv.html#a8e6ef4dc51f3daf2c6820f5ecf486adaa2880034c653349b7f9fcc2bb60342fc6">cv::FONT_HERSHEY_TRIPLEX</a> =  4, 
<a class="el" href="namespacecv.html#a8e6ef4dc51f3daf2c6820f5ecf486adaadfd28fc57520df956e00c7a26fb718ed">cv::FONT_HERSHEY_COMPLEX_SMALL</a> =  5, 
<a class="el" href="namespacecv.html#a8e6ef4dc51f3daf2c6820f5ecf486adaa58de14ee43572b502c8cb71f788e9fdc">cv::FONT_HERSHEY_SCRIPT_SIMPLEX</a> =  6, 
<a class="el" href="namespacecv.html#a8e6ef4dc51f3daf2c6820f5ecf486adaa8e7f6a22d4aec98c59375649eee1c696">cv::FONT_HERSHEY_SCRIPT_COMPLEX</a> =  7, 
<br/>
&#160;&#160;<a class="el" href="namespacecv.html#a8e6ef4dc51f3daf2c6820f5ecf486adaaf0f7c8824fe42205076771a7b67661c2">cv::FONT_ITALIC</a> =  16
<br/>
 }</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#abedc1d9dd1836c45f34c9bd44040581b">cv::absdiff</a> (const Mat &amp;src1, const Mat &amp;src2, CV_OUT Mat &amp;dst)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes element-wise absolute difference of two arrays (dst = abs(src1 - src2))  <a href="#abedc1d9dd1836c45f34c9bd44040581b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a68048eb7a049c3f6ee603759bbde6abb">cv::absdiff</a> (const Mat &amp;src1, const Scalar &amp;src2, CV_OUT Mat &amp;dst)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes element-wise absolute difference of array and scalar (dst = abs(src1 - src2))  <a href="#a68048eb7a049c3f6ee603759bbde6abb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a5fe1c189a97c40a07be2b31a7bc90e9e">cv::add</a> (const Mat &amp;src1, const Mat &amp;src2, CV_OUT Mat &amp;dst, const Mat &amp;mask CV_WRAP_DEFAULT(Mat()))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">adds one matrix to another (dst = src1 + src2)  <a href="#a5fe1c189a97c40a07be2b31a7bc90e9e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ab6bb31768c1fa5b8ec1e0e597f11a472">cv::add</a> (const Mat &amp;src1, const Scalar &amp;src2, CV_OUT Mat &amp;dst, const Mat &amp;mask=Mat())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">adds scalar to a matrix (dst = src1 + src2)  <a href="#ab6bb31768c1fa5b8ec1e0e597f11a472"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ad2f5a5a6187760b210907e57ef20515f">cv::add</a> (const Mat &amp;src1, const Mat &amp;src2, CV_OUT Mat &amp;dst)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">adds one matrix to another (dst = src1 + src2)  <a href="#ad2f5a5a6187760b210907e57ef20515f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a7a787331620fff73cfc26d1dc4ad5f31">cv::addWeighted</a> (const Mat &amp;src1, double alpha, const Mat &amp;src2, double beta, double gamma, CV_OUT Mat &amp;dst)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes weighted sum of two arrays (dst = alpha*src1 + beta*src2 + gamma)  <a href="#a7a787331620fff73cfc26d1dc4ad5f31"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a32569aad640af443eee05eb775c37923">cv::bitwise_and</a> (const Mat &amp;src1, const Mat &amp;src2, CV_OUT Mat &amp;dst, const Mat &amp;mask=Mat())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes bitwise conjunction of the two arrays (dst = src1 &amp; src2)  <a href="#a32569aad640af443eee05eb775c37923"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#aa8eae72a28be324579e18c703abf76c7">cv::bitwise_and</a> (const Mat &amp;src1, const Scalar &amp;src2, CV_OUT Mat &amp;dst, const Mat &amp;mask=Mat())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes bitwise conjunction of an array and scalar (dst = src1 &amp; src2)  <a href="#aa8eae72a28be324579e18c703abf76c7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#aa0ac5c570119b0fd7ffbe4b5992782d1">cv::bitwise_not</a> (const Mat &amp;src, CV_OUT Mat &amp;dst)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">inverts each bit of array (dst = ~src)  <a href="#aa0ac5c570119b0fd7ffbe4b5992782d1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ae3fbf416b6586350797ea892062c2b24">cv::bitwise_or</a> (const Mat &amp;src1, const Mat &amp;src2, CV_OUT Mat &amp;dst, const Mat &amp;mask=Mat())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes bitwise disjunction of the two arrays (dst = src1 | src2)  <a href="#ae3fbf416b6586350797ea892062c2b24"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#aeb48591a499821fe874612f8cd47a830">cv::bitwise_or</a> (const Mat &amp;src1, const Scalar &amp;src2, CV_OUT Mat &amp;dst, const Mat &amp;mask=Mat())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes bitwise disjunction of an array and scalar (dst = src1 | src2)  <a href="#aeb48591a499821fe874612f8cd47a830"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a4ca8df52221c629495f098968b670fee">cv::bitwise_xor</a> (const Mat &amp;src1, const Mat &amp;src2, CV_OUT Mat &amp;dst, const Mat &amp;mask=Mat())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes bitwise exclusive-or of the two arrays (dst = src1 ^ src2)  <a href="#a4ca8df52221c629495f098968b670fee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a8e4c5e2cf41c7e25ef506ced56cf38b0">cv::bitwise_xor</a> (const Mat &amp;src1, const Scalar &amp;src2, CV_OUT Mat &amp;dst, const Mat &amp;mask=Mat())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes bitwise exclusive-or of an array and scalar (dst = src1 ^ src2)  <a href="#a8e4c5e2cf41c7e25ef506ced56cf38b0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ae6ffa9354633f984246945d52823165d">cv::calcCovarMatrix</a> (const Mat *samples, int nsamples, Mat &amp;covar, Mat &amp;mean, int <a class="el" href="highgui__c_8h.html#a537e9e30547f68fff6358cc410095bb9">flags</a>, int ctype=CV_64F)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes covariation matrix of a set of samples  <a href="#ae6ffa9354633f984246945d52823165d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a796e08bfa731d4e7347e24605efab858">cv::calcCovarMatrix</a> (const Mat &amp;samples, CV_OUT Mat &amp;covar, CV_OUT Mat &amp;mean, int <a class="el" href="highgui__c_8h.html#a537e9e30547f68fff6358cc410095bb9">flags</a>, int ctype=CV_64F)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes covariation matrix of a set of samples  <a href="#a796e08bfa731d4e7347e24605efab858"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a1132811eea81e850a8dbe4492495098e">cv::cartToPolar</a> (const Mat &amp;<a class="el" href="highgui__c_8h.html#ad77deca22f617d3f0e0eb786445689fc">x</a>, const Mat &amp;<a class="el" href="highgui__c_8h.html#a9298c7ad619074f5285b32c6b72bfdea">y</a>, CV_OUT Mat &amp;magnitude, CV_OUT Mat &amp;angle, bool angleInDegrees=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">converts Cartesian coordinates to polar  <a href="#a1132811eea81e850a8dbe4492495098e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a66c4ca8120f8fe97b87e358d626b06b7">cv::checkHardwareSupport</a> (int feature)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a78a7780201d489585f639b76ad0fe2ff">cv::checkRange</a> (const Mat &amp;a, bool quiet=true, CV_OUT Point *pt=0, double minVal=-DBL_MAX, double maxVal=DBL_MAX)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">checks that each matrix element is within the specified range.  <a href="#a78a7780201d489585f639b76ad0fe2ff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a3ace31b951d2e2b6ca566c0515d1b609">cv::circle</a> (Mat &amp;img, Point center, int radius, const Scalar &amp;color, int thickness=1, int lineType=8, int shift=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">draws the circle outline or a solid circle in the image  <a href="#a3ace31b951d2e2b6ca566c0515d1b609"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#aa83bdc0f5ed65394990dc9c76484a8be">cv::clipLine</a> (Size imgSize, CV_IN_OUT Point &amp;pt1, CV_IN_OUT Point &amp;pt2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">clips the line segment by the rectangle Rect(0, 0, imgSize.width, imgSize.height)  <a href="#aa83bdc0f5ed65394990dc9c76484a8be"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a54fc21eeb2b834184d04b37dbce79363">cv::clipLine</a> (Rect imgRect, CV_IN_OUT Point &amp;pt1, CV_IN_OUT Point &amp;pt2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">clips the line segment by the rectangle imgRect  <a href="#a54fc21eeb2b834184d04b37dbce79363"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a15eac4562eb011a4b252c60e18a46768">cv::compare</a> (const Mat &amp;src1, double s, CV_OUT Mat &amp;dst, int cmpop)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">compares elements of array with scalar (dst = src1 &lt;cmpop&gt; src2)  <a href="#a15eac4562eb011a4b252c60e18a46768"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a7b21c8c22350623a0895ccd506b954d7">cv::compare</a> (const Mat &amp;src1, const Mat &amp;src2, CV_OUT Mat &amp;dst, int cmpop)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">compares elements of two arrays (dst = src1 &lt;cmpop&gt; src2)  <a href="#a7b21c8c22350623a0895ccd506b954d7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ae5097dd9fc369f49f4025a99fd48e086">cv::completeSymm</a> (Mat &amp;mtx, bool lowerToUpper=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">extends the symmetrical matrix from the lower half or from the upper half  <a href="#ae5097dd9fc369f49f4025a99fd48e086"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a23c74f01bd87b50b4d26c1238c816f5e">cv::convertScaleAbs</a> (const Mat &amp;src, CV_OUT Mat &amp;dst, double alpha=1, double beta=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">scales array elements, computes absolute values and converts the results to 8-bit unsigned integers: dst(i)=saturate_cast&lt;uchar&gt;abs(src(i)*alpha+beta)  <a href="#a23c74f01bd87b50b4d26c1238c816f5e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a95fdba31b9e9aa20b3dcb3fabc453b2e">cv::countNonZero</a> (const Mat &amp;src)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the number of nonzero array elements  <a href="#a95fdba31b9e9aa20b3dcb3fabc453b2e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a4d064b83b4a7d49cf55176073dcd562c">cv::cubeRoot</a> (float val)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes cube root of the argument  <a href="#a4d064b83b4a7d49cf55176073dcd562c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a5a7f94e0cd779061f3835f559d72e77c">cv::cvarrToMat</a> (const <a class="el" href="core_2include_2opencv2_2core_2types__c_8h.html#ac5046bc0456e9295d80b37774384798c">CvArr</a> *arr, bool copyData=false, bool allowND=true, int coiMode=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">converts array (<a class="el" href="struct_cv_mat.html">CvMat</a> or IplImage) to <a class="el" href="classcv_1_1_mat.html">cv::Mat</a>  <a href="#a5a7f94e0cd779061f3835f559d72e77c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ab3cc0feeee99c14703ecec7a8372bc75">cv::dct</a> (const Mat &amp;src, CV_OUT Mat &amp;dst, int <a class="el" href="highgui__c_8h.html#a537e9e30547f68fff6358cc410095bb9">flags</a>=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">performs forward or inverse 1D or 2D Discrete Cosine Transformation  <a href="#ab3cc0feeee99c14703ecec7a8372bc75"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#acd74e4d69874efdc2365382d1fa80b23">cv::determinant</a> (const Mat &amp;mtx)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes determinant of a square matrix  <a href="#acd74e4d69874efdc2365382d1fa80b23"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a26add08bde3a4f6a2a93ccdaac2b0dbc">cv::dft</a> (const Mat &amp;src, CV_OUT Mat &amp;dst, int <a class="el" href="highgui__c_8h.html#a537e9e30547f68fff6358cc410095bb9">flags</a>=0, int nonzeroRows=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">performs forward or inverse 1D or 2D Discrete Fourier Transformation  <a href="#a26add08bde3a4f6a2a93ccdaac2b0dbc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ae97060dcfdb21f567684214ca90101e6">cv::divide</a> (const Mat &amp;src1, const Mat &amp;src2, CV_OUT Mat &amp;dst, double scale=1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes element-wise weighted quotient of the two arrays (dst = scale*src1/src2)  <a href="#ae97060dcfdb21f567684214ca90101e6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a5c78f6d981c8dfda23a7e941c008eab5">cv::divide</a> (double scale, const Mat &amp;src2, CV_OUT Mat &amp;dst)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes element-wise weighted reciprocal of an array (dst = scale/src2)  <a href="#a5c78f6d981c8dfda23a7e941c008eab5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a809a21228c5b5c2d3eb9d40e56f14fb3">cv::eigen</a> (const Mat &amp;src, CV_OUT Mat &amp;eigenvalues, int lowindex=-1, int highindex=-1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">finds eigenvalues of a symmetric matrix  <a href="#a809a21228c5b5c2d3eb9d40e56f14fb3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#aeda10a116f5c5dae7e0114adf662717d">cv::eigen</a> (const Mat &amp;src, CV_OUT Mat &amp;eigenvalues, CV_OUT Mat &amp;eigenvectors, int lowindex=-1, int highindex=-1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">finds eigenvalues and eigenvectors of a symmetric matrix  <a href="#aeda10a116f5c5dae7e0114adf662717d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ad8e5846cb55917d0c6d8669d67e00a21">cv::ellipse</a> (Mat &amp;img, Point center, Size axes, double angle, double startAngle, double endAngle, const Scalar &amp;color, int thickness=1, int lineType=8, int shift=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">draws an elliptic arc, ellipse sector or a rotated ellipse in the image  <a href="#ad8e5846cb55917d0c6d8669d67e00a21"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#adb3874f09bd7b3b54fe1cb892d78f9a0">cv::ellipse</a> (Mat &amp;img, const RotatedRect &amp;box, const Scalar &amp;color, int thickness=1, int lineType=8)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">draws a rotated ellipse in the image  <a href="#adb3874f09bd7b3b54fe1cb892d78f9a0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#aa7e62ecfc1b8e535ebdb2080560c2819">cv::ellipse2Poly</a> (Point center, Size axes, int angle, int arcStart, int arcEnd, int delta, CV_OUT vector&lt; Point &gt; &amp;pts)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">converts elliptic arc to a polygonal curve  <a href="#aa7e62ecfc1b8e535ebdb2080560c2819"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a4910d7f86336cd4eff9dd05575667e41">cv::error</a> (const Exception &amp;exc)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Signals an error and raises the exception.  <a href="#a4910d7f86336cd4eff9dd05575667e41"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ab92ce84936135d98dae706fc1ca7c66f">cv::exp</a> (const Mat &amp;src, CV_OUT Mat &amp;dst)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes exponent of each matrix element (dst = e**src)  <a href="#ab92ce84936135d98dae706fc1ca7c66f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ad2a4409834f6bca902a25667bafc5aa9">cv::extractImageCOI</a> (const <a class="el" href="core_2include_2opencv2_2core_2types__c_8h.html#ac5046bc0456e9295d80b37774384798c">CvArr</a> *arr, CV_OUT Mat &amp;coiimg, int coi=-1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">extracts Channel of Interest from <a class="el" href="struct_cv_mat.html">CvMat</a> or IplImage and makes <a class="el" href="classcv_1_1_mat.html">cv::Mat</a> out of it.  <a href="#ad2a4409834f6bca902a25667bafc5aa9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ab992f84022886e0b3df4ccdd5760f0dc">cv::fastAtan2</a> (float <a class="el" href="highgui__c_8h.html#a9298c7ad619074f5285b32c6b72bfdea">y</a>, float <a class="el" href="highgui__c_8h.html#ad77deca22f617d3f0e0eb786445689fc">x</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the angle in degrees (0..360) of the vector (x,y)  <a href="#ab992f84022886e0b3df4ccdd5760f0dc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a4b0d54a6957761ba64880fa51c4b8a6b">cv::fastFree</a> (void *ptr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a0ad6f1fcb40635cb776ade61f9b88c6e">cv::fastMalloc</a> (size_t bufSize)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a936205b9b3d8c69f27be8111ddd056b6">cv::fillConvexPoly</a> (Mat &amp;img, const Point *pts, int npts, const Scalar &amp;color, int lineType=8, int shift=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">draws a filled convex polygon in the image  <a href="#a936205b9b3d8c69f27be8111ddd056b6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a32c3853ef3688ed81ec0e9c1e9fc72ef">cv::fillPoly</a> (Mat &amp;img, const Point **pts, const int *npts, int ncontours, const Scalar &amp;color, int lineType=8, int shift=0, Point offset=Point())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">fills an area bounded by one or more polygons  <a href="#a32c3853ef3688ed81ec0e9c1e9fc72ef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a318c6c854831ad541ac9c37c2f9d1fce">cv::flip</a> (const Mat &amp;src, CV_OUT Mat &amp;dst, int flipCode)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">reverses the order of the rows, columns or both in a matrix  <a href="#a318c6c854831ad541ac9c37c2f9d1fce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a60a078dac5999f57563caf7c6600460f">cv::format</a> (const char *fmt,...)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a3d0f85d77fa415d613cc4190ff791cba">cv::fromUtf16</a> (const WString &amp;str)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a665e5d80b292f32e8f206a577fa25098">cv::gemm</a> (const Mat &amp;src1, const Mat &amp;src2, double alpha, const Mat &amp;src3, double gamma, CV_OUT Mat &amp;dst, int <a class="el" href="highgui__c_8h.html#a537e9e30547f68fff6358cc410095bb9">flags</a>=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">implements generalized matrix product algorithm GEMM from BLAS  <a href="#a665e5d80b292f32e8f206a577fa25098"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ConvertData&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a0adcb4108409b36a0e8e44aa2ebaa349">cv::getConvertElem</a> (int fromType, int toType)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the function for converting pixels from one data type to another  <a href="#a0adcb4108409b36a0e8e44aa2ebaa349"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ConvertScaleData&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#af453d59159d541d9942cf0c8ca84047b">cv::getConvertScaleElem</a> (int fromType, int toType)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the function for converting pixels from one data type to another with the optional scaling  <a href="#af453d59159d541d9942cf0c8ca84047b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="core_2include_2opencv2_2core_2types__c_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#af3070efdcfef6f1e7ac28d2b6a29a7c0">cv::getCPUTickCount</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a2db334ec41d98da3129ef4a2342fc4d4">cv::getNumThreads</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a65771bed36f50b52998c2a9131db19da">cv::getOptimalDFTSize</a> (int vecsize)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the minimal vector size vecsize1 &gt;= vecsize so that the <a class="el" href="namespacecv.html#a26add08bde3a4f6a2a93ccdaac2b0dbc" title="performs forward or inverse 1D or 2D Discrete Fourier Transformation">dft()</a> of the vector of length vecsize1 can be computed efficiently  <a href="#a65771bed36f50b52998c2a9131db19da"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W Size&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a482cdab6db1351cfad14868810b14660">cv::getTextSize</a> (const string &amp;text, int fontFace, double fontScale, int thickness, CV_OUT int *baseLine)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">returns bounding box of the text string  <a href="#a482cdab6db1351cfad14868810b14660"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#af9cc0cb10097686a9da60f6c587e5774">cv::getThreadNum</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="core_2include_2opencv2_2core_2types__c_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ae73f58000611a1af25dd36d496bf4487">cv::getTickCount</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of ticks.  <a href="#ae73f58000611a1af25dd36d496bf4487"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a6ae2c0b0a8f5837a02f42fb9a41dcb5a">cv::getTickFrequency</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ac9c52f15957dc4486c423213c8a53a09">cv::hconcat</a> (const Mat *src, size_t nsrc, Mat &amp;dst)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a08e91cf61ab61a0cbce1825b16eeed01">cv::hconcat</a> (const Mat &amp;src1, const Mat &amp;src2, Mat &amp;dst)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ae7f2fbd3b43de25f9ec83bdad4222bcc">cv::hconcat</a> (const vector&lt; Mat &gt; &amp;src, CV_OUT Mat &amp;dst)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ab0057e2890c4b0670f7839219a5a761d">cv::idct</a> (const Mat &amp;src, CV_OUT Mat &amp;dst, int <a class="el" href="highgui__c_8h.html#a537e9e30547f68fff6358cc410095bb9">flags</a>=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">performs inverse 1D or 2D Discrete Cosine Transformation  <a href="#ab0057e2890c4b0670f7839219a5a761d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a121a5388c9c9467b9e1a12aa57260c23">cv::idft</a> (const Mat &amp;src, CV_OUT Mat &amp;dst, int <a class="el" href="highgui__c_8h.html#a537e9e30547f68fff6358cc410095bb9">flags</a>=0, int nonzeroRows=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">performs inverse 1D or 2D Discrete Fourier Transformation  <a href="#a121a5388c9c9467b9e1a12aa57260c23"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a49d94072be85853ec5bfac4abb306e09">cv::inRange</a> (const Mat &amp;src, const Mat &amp;lowerb, const Mat &amp;upperb, CV_OUT Mat &amp;dst)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">set mask elements for those array elements which are within the element-specific bounding box (dst = lowerb &lt;= src &amp;&amp; src &lt; upperb)  <a href="#a49d94072be85853ec5bfac4abb306e09"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a3ceaaecdac478bd8d0d960b01eaec498">cv::inRange</a> (const Mat &amp;src, const Scalar &amp;lowerb, const Scalar &amp;upperb, CV_OUT Mat &amp;dst)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">set mask elements for those array elements which are within the fixed bounding box (dst = lowerb &lt;= src &amp;&amp; src &lt; upperb)  <a href="#a3ceaaecdac478bd8d0d960b01eaec498"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a5f34adc93c9256e80098b0bb242e9bf3">cv::insertImageCOI</a> (const Mat &amp;coiimg, <a class="el" href="core_2include_2opencv2_2core_2types__c_8h.html#ac5046bc0456e9295d80b37774384798c">CvArr</a> *arr, int coi=-1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">inserts single-channel <a class="el" href="classcv_1_1_mat.html">cv::Mat</a> into a multi-channel <a class="el" href="struct_cv_mat.html">CvMat</a> or IplImage  <a href="#a5f34adc93c9256e80098b0bb242e9bf3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#aebfc4553f25681bd7884c787f1a40f6f">cv::invert</a> (const Mat &amp;src, CV_OUT Mat &amp;dst, int <a class="el" href="highgui__c_8h.html#a537e9e30547f68fff6358cc410095bb9">flags</a>=DECOMP_LU)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes inverse or pseudo-inverse matrix  <a href="#aebfc4553f25681bd7884c787f1a40f6f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a4b29fb324066cd02afc7cd5d9d7431eb">cv::kmeans</a> (const Mat &amp;data, int K, CV_OUT Mat &amp;bestLabels, TermCriteria criteria, int attempts, int <a class="el" href="highgui__c_8h.html#a537e9e30547f68fff6358cc410095bb9">flags</a>, CV_OUT Mat *centers=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">clusters the input data using k-Means algorithm  <a href="#a4b29fb324066cd02afc7cd5d9d7431eb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a69c32f48fbb2dfeef952a9690184d0c2">cv::line</a> (Mat &amp;img, Point pt1, Point pt2, const Scalar &amp;color, int thickness=1, int lineType=8, int shift=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">draws the line segment (pt1, pt2) in the image  <a href="#a69c32f48fbb2dfeef952a9690184d0c2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a756c152c515f5c06a736fadaef56842f">cv::log</a> (const Mat &amp;src, CV_OUT Mat &amp;dst)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes natural logarithm of absolute value of each matrix element: dst = log(abs(src))  <a href="#a756c152c515f5c06a736fadaef56842f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a287dd6f8d898dbee5fe6c198e8f72fce">cv::LUT</a> (const Mat &amp;src, const Mat &amp;lut, CV_OUT Mat &amp;dst)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">transforms 8-bit unsigned integers using lookup table: dst(i)=lut(src(i))  <a href="#a287dd6f8d898dbee5fe6c198e8f72fce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a5ceec35af873e4ad7d149219ff32c069">cv::magnitude</a> (const Mat &amp;<a class="el" href="highgui__c_8h.html#ad77deca22f617d3f0e0eb786445689fc">x</a>, const Mat &amp;<a class="el" href="highgui__c_8h.html#a9298c7ad619074f5285b32c6b72bfdea">y</a>, CV_OUT Mat &amp;magnitude)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes magnitude (magnitude(i)) of each (x(i), y(i)) vector  <a href="#a5ceec35af873e4ad7d149219ff32c069"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ada5dbf8b39a9d6aff36dee8568c9d634">cv::Mahalanobis</a> (const Mat &amp;v1, const Mat &amp;v2, const Mat &amp;icovar)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes Mahalanobis distance between two vectors: sqrt((v1-v2)'*icovar*(v1-v2)), where icovar is the inverse covariation matrix  <a href="#ada5dbf8b39a9d6aff36dee8568c9d634"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a148276d2fb5f15b8b0d89377df2527a9">cv::Mahalonobis</a> (const Mat &amp;v1, const Mat &amp;v2, const Mat &amp;icovar)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">a synonym for Mahalanobis  <a href="#a148276d2fb5f15b8b0d89377df2527a9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a57416e28468db6ec3f09e4a133a2c224">cv::max</a> (const Mat &amp;src1, const Mat &amp;src2, CV_OUT Mat &amp;dst)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes per-element maximum of two arrays (dst = max(src1, src2))  <a href="#a57416e28468db6ec3f09e4a133a2c224"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a1c4205ebfaba9c62c38781e6a4890a32">cv::max</a> (const Mat &amp;src1, double src2, CV_OUT Mat &amp;dst)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes per-element maximum of array and scalar (dst = max(src1, src2))  <a href="#a1c4205ebfaba9c62c38781e6a4890a32"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a79846b4aa959b7301f7d446fbc6bfa21">cv::mean</a> (const Mat &amp;src)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes mean value of array elements  <a href="#a79846b4aa959b7301f7d446fbc6bfa21"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W Scalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#abd0a824d3de9f9f0bcf232424de2d5ea">cv::mean</a> (const Mat &amp;src, const Mat &amp;mask CV_WRAP_DEFAULT(Mat()))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes mean value of selected array elements  <a href="#abd0a824d3de9f9f0bcf232424de2d5ea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a74c2b508eafe88ca623ca5b4c9e1efcb">cv::meanStdDev</a> (const Mat &amp;src, CV_OUT Scalar &amp;mean, CV_OUT Scalar &amp;stddev, const Mat &amp;mask=Mat())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes mean value and standard deviation of all or selected array elements  <a href="#a74c2b508eafe88ca623ca5b4c9e1efcb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ab714cb9ebca8896316922b7580b3f4e1">cv::merge</a> (const Mat *mv, size_t count, CV_OUT Mat &amp;dst)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">makes multi-channel array out of several single-channel arrays  <a href="#ab714cb9ebca8896316922b7580b3f4e1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a7f7f3783ad76bddcd26e6aa715e71ac6">cv::merge</a> (const vector&lt; Mat &gt; &amp;mv, Mat &amp;dst)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">makes multi-channel array out of several single-channel arrays  <a href="#a7f7f3783ad76bddcd26e6aa715e71ac6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a0bdeb3ee8259d5df4655f38d41099070">cv::min</a> (const Mat &amp;src1, const Mat &amp;src2, CV_OUT Mat &amp;dst)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes per-element minimum of two arrays (dst = min(src1, src2))  <a href="#a0bdeb3ee8259d5df4655f38d41099070"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ad374cb6ad2e0768ba20722a9f3ad8f6d">cv::min</a> (const Mat &amp;src1, double src2, CV_OUT Mat &amp;dst)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes per-element minimum of array and scalar (dst = min(src1, src2))  <a href="#ad374cb6ad2e0768ba20722a9f3ad8f6d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a4bd93bfdfa1c360fb4855f3123a62c16">cv::minMaxIdx</a> (const Mat &amp;src, double *minVal, double *maxVal, int *minIdx=0, int *maxIdx=0, const Mat &amp;mask=Mat())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a8873b86a29c5af51cafdcee82f8150a7">cv::minMaxLoc</a> (const SparseMat &amp;a, double *minVal, double *maxVal, int *minIdx=0, int *maxIdx=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">finds global minimum and maximum sparse array elements and returns their values and their locations  <a href="#a8873b86a29c5af51cafdcee82f8150a7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a7afc836422a6e9a0a1d1b046f8bcd34b">cv::minMaxLoc</a> (const Mat &amp;src, CV_OUT double *minVal, CV_OUT double *maxVal=0, CV_OUT Point *minLoc=0, CV_OUT Point *maxLoc=0, const Mat &amp;mask=Mat())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">finds global minimum and maximum array elements and returns their values and their locations  <a href="#a7afc836422a6e9a0a1d1b046f8bcd34b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#abef5509e7c68226656588ae9feaf084a">cv::mixChannels</a> (const vector&lt; Mat &gt; &amp;src, vector&lt; Mat &gt; &amp;dst, const int *fromTo, int npairs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a51d768c270a1cdd3497255017c4504be">cv::mixChannels</a> (const Mat *src, size_t nsrcs, Mat *dst, size_t ndsts, const int *fromTo, size_t npairs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">copies selected channels from the input arrays to the selected channels of the output arrays  <a href="#a51d768c270a1cdd3497255017c4504be"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ad9a5aac6adf884c881e67314780d905a">cv::mulSpectrums</a> (const Mat &amp;a, const Mat &amp;b, CV_OUT Mat &amp;c, int <a class="el" href="highgui__c_8h.html#a537e9e30547f68fff6358cc410095bb9">flags</a>, bool conjB=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes element-wise product of the two Fourier spectrums. The second spectrum can optionally be conjugated before the multiplication  <a href="#ad9a5aac6adf884c881e67314780d905a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ab1dfe620989ac16be13264684246f9f3">cv::multiply</a> (const Mat &amp;src1, const Mat &amp;src2, CV_OUT Mat &amp;dst, double scale=1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes element-wise weighted product of the two arrays (dst = scale*src1*src2)  <a href="#ab1dfe620989ac16be13264684246f9f3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ae72ca555d2363b0fcec895a7f0b25ab5">cv::mulTransposed</a> (const Mat &amp;src, CV_OUT Mat &amp;dst, bool aTa, const Mat &amp;delta=Mat(), double scale=1, int rtype=-1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">multiplies matrix by its transposition from the left or from the right  <a href="#ae72ca555d2363b0fcec895a7f0b25ab5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a7c331fb8dd951707e184ef4e3f21dd33">cv::norm</a> (const SparseMat &amp;src, int normType)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes norm of a sparse matrix  <a href="#a7c331fb8dd951707e184ef4e3f21dd33"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a7dd251dcee9893767838fff3d80554b3">cv::norm</a> (const Mat &amp;src1, int normType=NORM_L2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes norm of array  <a href="#a7dd251dcee9893767838fff3d80554b3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ac8182982fa92664bf52470304a70955b">cv::norm</a> (const Mat &amp;src1, const Mat &amp;src2, int normType=NORM_L2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes norm of the difference between two arrays  <a href="#ac8182982fa92664bf52470304a70955b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a426bb7dc8a3db7ea33de331f29dbcf1d">cv::norm</a> (const Mat &amp;src1, const Mat &amp;src2, int normType, const Mat &amp;mask CV_WRAP_DEFAULT(Mat()))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes norm of selected part of the difference between two arrays  <a href="#a426bb7dc8a3db7ea33de331f29dbcf1d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a5cec307e1f20cd59d3677bbefc782a50">cv::norm</a> (const Mat &amp;src1, int normType, const Mat &amp;mask CV_WRAP_DEFAULT(Mat()))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes norm of the selected array part  <a href="#a5cec307e1f20cd59d3677bbefc782a50"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a7bcf47a1df78cf575162e0aed44960cb">cv::normalize</a> (const SparseMat &amp;src, SparseMat &amp;dst, double alpha, int normType)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">scales and shifts array elements so that either the specified norm (alpha) or the minimum (alpha) and maximum (beta) array values get the specified values  <a href="#a7bcf47a1df78cf575162e0aed44960cb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a56e4378b170a97ff6e6f3a25b87c8052">cv::normalize</a> (const Mat &amp;src, CV_OUT Mat &amp;dst, double alpha=1, double beta=0, int norm_type=NORM_L2, int rtype=-1, const Mat &amp;mask=Mat())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">scales and shifts array elements so that either the specified norm (alpha) or the minimum (alpha) and maximum (beta) array values get the specified values  <a href="#a56e4378b170a97ff6e6f3a25b87c8052"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a90d469dfd90cdc3904bb8b4179ec896d">cv::perspectiveTransform</a> (const Mat &amp;src, CV_OUT Mat &amp;dst, const Mat &amp;m)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">performs perspective transformation of each element of multi-channel input matrix  <a href="#a90d469dfd90cdc3904bb8b4179ec896d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#adc149342aa9ee01302cac713e95fcb57">cv::phase</a> (const Mat &amp;<a class="el" href="highgui__c_8h.html#ad77deca22f617d3f0e0eb786445689fc">x</a>, const Mat &amp;<a class="el" href="highgui__c_8h.html#a9298c7ad619074f5285b32c6b72bfdea">y</a>, CV_OUT Mat &amp;angle, bool angleInDegrees=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes angle (angle(i)) of each (x(i), y(i)) vector  <a href="#adc149342aa9ee01302cac713e95fcb57"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a3223fa55778440615cd76a01eed68d97">cv::polarToCart</a> (const Mat &amp;magnitude, const Mat &amp;angle, CV_OUT Mat &amp;<a class="el" href="highgui__c_8h.html#ad77deca22f617d3f0e0eb786445689fc">x</a>, CV_OUT Mat &amp;<a class="el" href="highgui__c_8h.html#a9298c7ad619074f5285b32c6b72bfdea">y</a>, bool angleInDegrees=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">converts polar coordinates to Cartesian  <a href="#a3223fa55778440615cd76a01eed68d97"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a98e9282d013e32777b73456bb774d4cf">cv::polylines</a> (Mat &amp;img, const Point **pts, const int *npts, int ncontours, bool isClosed, const Scalar &amp;color, int thickness=1, int lineType=8, int shift=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">draws one or more polygonal curves  <a href="#a98e9282d013e32777b73456bb774d4cf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ab4590cb42c8e000c857b12ce13b067ec">cv::pow</a> (const Mat &amp;src, double power, CV_OUT Mat &amp;dst)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">raises the input matrix elements to the specified power (b = a**power)  <a href="#ab4590cb42c8e000c857b12ce13b067ec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a9564d5456183b37be3801363c104dfb5">cv::putText</a> (Mat &amp;img, const string &amp;text, Point org, int fontFace, double fontScale, Scalar color, int thickness=1, int linetype=8, bool bottomLeftOrigin=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">renders text string in the image  <a href="#a9564d5456183b37be3801363c104dfb5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#affe40e88240e6d95fde1f0d7c49a05bc">cv::randn</a> (CV_OUT Mat &amp;dst, const Scalar &amp;mean, const Scalar &amp;stddev)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">fills array with normally-distributed random numbers with the specified mean and the standard deviation  <a href="#affe40e88240e6d95fde1f0d7c49a05bc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a9d7b672b4b4262913a10d0df7256136c">cv::randShuffle</a> (Mat &amp;dst, double iterFactor=1., RNG *rng=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">shuffles the input array elements  <a href="#a9d7b672b4b4262913a10d0df7256136c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a202aa2a83fce84cde1585c1f4c484a5d">cv::randu</a> (CV_OUT Mat &amp;dst, const Scalar &amp;low, const Scalar &amp;high)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">fills array with uniformly-distributed random numbers from the range [low, high)  <a href="#a202aa2a83fce84cde1585c1f4c484a5d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a2a31b41c9fc293c61199c828a5bb96f7">cv::rectangle</a> (Mat &amp;img, Point pt1, Point pt2, const Scalar &amp;color, int thickness=1, int lineType=8, int shift=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">draws the rectangle outline or a solid rectangle with the opposite corners pt1 and pt2 in the image  <a href="#a2a31b41c9fc293c61199c828a5bb96f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a6072290bc4c00d551aaeca8e82d15870">cv::rectangle</a> (Mat &amp;img, Rect rec, const Scalar &amp;color, int thickness=1, int lineType=8, int shift=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">draws the rectangle outline or a solid rectangle covering rec in the image  <a href="#a6072290bc4c00d551aaeca8e82d15870"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ErrorCallback&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a8cd28eccccb695570cdaf86a572d2c0c">cv::redirectError</a> (ErrorCallback errCallback, void *userdata=0, void **prevUserdata=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the new error handler and the optional user data.  <a href="#a8cd28eccccb695570cdaf86a572d2c0c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#aa30d7646a887c827af71e06fd390c2ba">cv::reduce</a> (const Mat &amp;src, CV_OUT Mat &amp;dst, int dim, int rtype, int dtype=-1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">transforms 2D matrix to 1D row or column vector by taking sum, minimum, maximum or mean value over all the rows  <a href="#aa30d7646a887c827af71e06fd390c2ba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a96ba9fa1ab623bfff73d4770717c4a50">cv::repeat</a> (const Mat &amp;src, int ny, int nx, CV_OUT Mat &amp;dst)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">replicates the input matrix the specified number of times in the horizontal and/or vertical direction  <a href="#a96ba9fa1ab623bfff73d4770717c4a50"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a8e9c4ef56a85c58332c63997c10a51d8">cv::repeat</a> (const Mat &amp;src, int ny, int nx)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a72c224ca2e4f11d4c5d8f8b018d9cfd5">cv::scalarToRawData</a> (const Scalar &amp;s, void *buf, int type, int unroll_to=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a97d6a1d6834b9af9ad954faac01cbce8">cv::scaleAdd</a> (const Mat &amp;src1, double alpha, const Mat &amp;src2, CV_OUT Mat &amp;dst)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">adds scaled array to another one (dst = alpha*src1 + src2)  <a href="#a97d6a1d6834b9af9ad954faac01cbce8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ae4904ef072dede53cf161d9a6869083f">cv::setBreakOnError</a> (bool flag)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets/resets the break-on-error mode.  <a href="#ae4904ef072dede53cf161d9a6869083f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a2ad51d2770ec1c4ef097498754458724">cv::setIdentity</a> (Mat &amp;mtx, const Scalar &amp;s=Scalar(1))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">initializes scaled identity matrix  <a href="#a2ad51d2770ec1c4ef097498754458724"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ae78625c3c2aa9e0b83ed31b73c6549c0">cv::setNumThreads</a> (int nthreads)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ab738cf74be01e01bab8ca875abcf5314">cv::setUseOptimized</a> (bool onoff)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ae32334515bdc5f6bf008f240aa081902">cv::solve</a> (const Mat &amp;src1, const Mat &amp;src2, CV_OUT Mat &amp;dst, int <a class="el" href="highgui__c_8h.html#a537e9e30547f68fff6358cc410095bb9">flags</a>=DECOMP_LU)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">solves linear system or a least-square problem  <a href="#ae32334515bdc5f6bf008f240aa081902"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a570b5827ca4f8b8dd53368caa0649380">cv::solveCubic</a> (const Mat &amp;coeffs, CV_OUT Mat &amp;roots)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">finds real roots of a cubic polynomial  <a href="#a570b5827ca4f8b8dd53368caa0649380"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a334494c59476da55066c408dbae0bf1a">cv::solvePoly</a> (const Mat &amp;coeffs, CV_OUT Mat &amp;roots, int maxIters=300)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">finds real and complex roots of a polynomial  <a href="#a334494c59476da55066c408dbae0bf1a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#af66410d6ee3bba4d9c6628589574f9a9">cv::sort</a> (const Mat &amp;src, CV_OUT Mat &amp;dst, int <a class="el" href="highgui__c_8h.html#a537e9e30547f68fff6358cc410095bb9">flags</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">sorts independently each matrix row or each matrix column  <a href="#af66410d6ee3bba4d9c6628589574f9a9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a223b0de5b1c758cf0a6e850eec8470e3">cv::sortIdx</a> (const Mat &amp;src, CV_OUT Mat &amp;dst, int <a class="el" href="highgui__c_8h.html#a537e9e30547f68fff6358cc410095bb9">flags</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">sorts independently each matrix row or each matrix column  <a href="#a223b0de5b1c758cf0a6e850eec8470e3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#aa3f887a0b4f2e42428729da87b302973">cv::split</a> (const Mat &amp;m, vector&lt; Mat &gt; &amp;mv)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">copies each plane of a multi-channel array to a dedicated array  <a href="#aa3f887a0b4f2e42428729da87b302973"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a0547c7fed86152d7e9d0096029c8518a">cv::split</a> (const Mat &amp;src, Mat *mvbegin)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">copies each plane of a multi-channel array to a dedicated array  <a href="#a0547c7fed86152d7e9d0096029c8518a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#ad4272ced40e7db7cf6b8e74b1c0c4b89">cv::sqrt</a> (const Mat &amp;src, CV_OUT Mat &amp;dst)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes square root of each matrix element (dst = src**0.5)  <a href="#ad4272ced40e7db7cf6b8e74b1c0c4b89"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#aff08349a60f8e7b1b7375ec8cccdb834">cv::subtract</a> (const Mat &amp;src1, const Mat &amp;src2, CV_OUT Mat &amp;dst)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">subtracts one matrix from another (dst = src1 - src2)  <a href="#aff08349a60f8e7b1b7375ec8cccdb834"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a749cb8a7c9d7c24e49b79e0e4c6baa86">cv::subtract</a> (const Mat &amp;src1, const Scalar &amp;src2, CV_OUT Mat &amp;dst, const Mat &amp;mask=Mat())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">subtracts scalar from a matrix (dst = src1 - src2)  <a href="#a749cb8a7c9d7c24e49b79e0e4c6baa86"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a40a760d078991602107c87cf277be9f7">cv::subtract</a> (const Scalar &amp;src1, const Mat &amp;src2, CV_OUT Mat &amp;dst, const Mat &amp;mask=Mat())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">subtracts matrix from scalar (dst = src1 - src2)  <a href="#a40a760d078991602107c87cf277be9f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#aea33348fe2f848e1b59bf004c1cdad47">cv::subtract</a> (const Mat &amp;src1, const Mat &amp;src2, CV_OUT Mat &amp;dst, const Mat &amp;mask CV_WRAP_DEFAULT(Mat()))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">subtracts one matrix from another (dst = src1 - src2)  <a href="#aea33348fe2f848e1b59bf004c1cdad47"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W Scalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#aff9ed3cc703a0ab186cae1dee8a90e6d">cv::sum</a> (const Mat &amp;src)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes sum of array elements  <a href="#aff9ed3cc703a0ab186cae1dee8a90e6d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#afbc8f513f40dc1b7c2d48ea6a5a81776">cv::swap</a> (Mat &amp;a, Mat &amp;b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">swaps two matrices  <a href="#afbc8f513f40dc1b7c2d48ea6a5a81776"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RNG &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a75843061d150ad6564b5447e38e57722">cv::theRNG</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the thread-local Random number generator  <a href="#a75843061d150ad6564b5447e38e57722"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">WString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a8c4e113fc7bd605138b5df3008f507dd">cv::toUtf16</a> (const string &amp;str)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W Scalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a7b4d5d5578899159348cc36db34d4e15">cv::trace</a> (const Mat &amp;mtx)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes trace of a matrix  <a href="#a7b4d5d5578899159348cc36db34d4e15"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a2fc1afdc86c4b023c530a528d0a8ae3f">cv::transform</a> (const Mat &amp;src, CV_OUT Mat &amp;dst, const Mat &amp;m)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">performs affine transformation of each element of multi-channel input matrix  <a href="#a2fc1afdc86c4b023c530a528d0a8ae3f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a0ef9755551f9bf160a2c4c7775ad1f4c">cv::transpose</a> (const Mat &amp;src, CV_OUT Mat &amp;dst)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">transposes the matrix  <a href="#a0ef9755551f9bf160a2c4c7775ad1f4c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#accc4fbc3a4793f2052657076b8fc78c6">cv::useOptimized</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a415c53dba6c8ee7ffcf1412247f5389d">cv::vconcat</a> (const Mat &amp;src1, const Mat &amp;src2, Mat &amp;dst)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#af5c2608df867b0e10e33abdcb0ed4635">cv::vconcat</a> (const Mat *src, size_t nsrc, Mat &amp;dst)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv.html#a171018792e47ae164f8ca8e073cef3bb">cv::vconcat</a> (const vector&lt; Mat &gt; &amp;src, CV_OUT Mat &amp;dst)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>The Core Functionality. </p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="af62bcd90f70e275191ab95136d85906b"></a><!-- doxytag: member="core.hpp::CV_Assert" ref="af62bcd90f70e275191ab95136d85906b" args="(expr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CV_Assert</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">expr&#160;)</td>
          <td>&#160;&#160;&#160;if((expr)) ; else cv::error( <a class="el" href="classcv_1_1_exception.html">cv::Exception</a>(CV_StsAssert, #expr, &quot;&quot;, __FILE__, __LINE__) )</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="afbcb487cba05bd288dbe18c433de4f6f"></a><!-- doxytag: member="core.hpp::CV_DbgAssert" ref="afbcb487cba05bd288dbe18c433de4f6f" args="(expr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CV_DbgAssert</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">expr&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5b48c333c777666e076bd7052799f891"></a><!-- doxytag: member="core.hpp::CV_Error" ref="a5b48c333c777666e076bd7052799f891" args="(code, msg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CV_Error</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">code, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">msg&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;cv::error( <a class="el" href="classcv_1_1_exception.html">cv::Exception</a>(code, msg, &quot;&quot;, __FILE__, __LINE__) )</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a1c0cd6e5bd9a5f915c6cab9c0632f969"></a><!-- doxytag: member="core.hpp::CV_Error_" ref="a1c0cd6e5bd9a5f915c6cab9c0632f969" args="(code, args)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CV_Error_</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">code, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">args&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;cv::error( <a class="el" href="classcv_1_1_exception.html">cv::Exception</a>(code, cv::format args, &quot;&quot;, __FILE__, __LINE__) )</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Mon Feb 21 2011 10:00:49 for opencv by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.2 </small></address>
</body>
</html>
